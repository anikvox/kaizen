generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String            @id @default(cuid())
  clerkId         String            @unique
  email           String            @unique
  name            String?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  deviceTokens    DeviceToken[]
  websiteVisits   WebsiteVisit[]
  textAttentions  TextAttention[]
  imageAttentions ImageAttention[]
  audioAttentions AudioAttention[]
  youtubeAttentions YoutubeAttention[]
  settings        UserSettings?
  chatSessions    ChatSession[]
  focuses         Focus[]
  quizResults     QuizResult[]
  taskQueue       TaskQueue[]
  taskHistory     TaskHistory[]

  @@map("users")
}

model DeviceToken {
  id        String   @id @default(cuid())
  token     String   @unique
  name      String
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  lastUsedAt DateTime?

  @@map("device_tokens")
}

model WebsiteVisit {
  id            String    @id @default(cuid())
  url           String
  title         String
  metadata      Json      @default("{}")
  openedAt      DateTime
  closedAt      DateTime?
  activeTime    Int       @default(0) // in milliseconds
  referrer      String?
  summary       String?   @db.Text // AI-generated summary of text attention
  imageSummary  String?   @db.Text // AI-generated summary of image attention
  summarizedAt  DateTime? // Last time summary was generated
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@unique([userId, url, openedAt])
  @@index([userId])
  @@index([url])
  @@map("website_visits")
}

model TextAttention {
  id        String   @id @default(cuid())
  url       String
  text      String   @db.Text
  wordsRead Int
  timestamp DateTime
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([url])
  @@index([timestamp])
  @@map("text_attentions")
}

model ImageAttention {
  id            String    @id @default(cuid())
  url           String
  src           String
  alt           String
  title         String
  width         Int
  height        Int
  hoverDuration Int       // in milliseconds
  confidence    Int       // 0-100
  timestamp     DateTime
  summary       String?   @db.Text // AI-generated description of the image
  summarizedAt  DateTime? // Last time summary was generated
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt     DateTime  @default(now())

  @@index([userId])
  @@index([url])
  @@index([timestamp])
  @@map("image_attentions")
}

model AudioAttention {
  id               String   @id @default(cuid())
  url              String
  src              String
  title            String
  duration         Float    // in seconds
  playbackDuration Int      // in milliseconds
  currentTime      Float    // in seconds
  confidence       Int      // 0-100
  timestamp        DateTime
  userId           String
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt        DateTime @default(now())

  @@index([userId])
  @@index([url])
  @@index([timestamp])
  @@map("audio_attentions")
}

model YoutubeAttention {
  id              String   @id @default(cuid())
  videoId         String?
  event           String   // "opened" | "caption" | "active-watch-time-update"
  title           String?
  channelName     String?
  url             String?
  caption         String?  @db.Text
  activeWatchTime Int?     // in milliseconds
  timestamp       DateTime
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt       DateTime @default(now())

  @@index([userId])
  @@index([videoId])
  @@index([timestamp])
  @@map("youtube_attentions")
}

model UserSettings {
  id                            String   @id @default(cuid())
  userId                        String   @unique
  user                          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  // Current Active Tab (synced from extension)
  currentActiveUrl              String?
  currentActiveTitle            String?
  currentActiveAt               DateTime?
  // User Location (set by user via chat)
  location                      String?  // City name, e.g., "Tokyo", "New York"
  timezone                      String?  // Derived from location, e.g., "Asia/Tokyo"
  // Translation Preferences
  preferredTranslationLanguage  String?  // User's preferred language for translations, e.g., "Spanish", "French"
  // Cognitive Attention Settings
  cognitiveAttentionDebugMode   Boolean  @default(false)
  cognitiveAttentionShowOverlay Boolean  @default(false)
  attentionTrackingIgnoreList   String?  @db.Text // Newline-separated list of URL patterns/regexes to ignore
  // Summarization Settings
  attentionSummarizationEnabled Boolean  @default(true)
  attentionSummarizationIntervalMs Int   @default(60000) // Default 1 minute
  lastSummarizationCalculatedAt DateTime?                // Marker for last summarization run (per-user interval)
  // Focus Calculation Settings
  focusCalculationEnabled       Boolean  @default(true)
  focusCalculationIntervalMs    Int      @default(30000)   // Default 30 seconds
  focusInactivityThresholdMs    Int      @default(60000)   // Default 1 minute
  focusMinDurationMs            Int      @default(30000)   // Default 30 seconds (minimum before drift can create new focus)
  lastFocusCalculatedAt         DateTime?                  // Marker for last focus calculation (to avoid reprocessing attention)
  // LLM Settings
  llmProvider                   String?  // "gemini" | "anthropic" | "openai" | null (system default)
  llmModel                      String?  // Selected model for the provider
  geminiApiKeyEncrypted         String?  @db.Text
  anthropicApiKeyEncrypted      String?  @db.Text
  openaiApiKeyEncrypted         String?  @db.Text
  // Quiz Settings
  quizAnswerOptionsCount        Int      @default(2)    // 2, 3, or 4 answer options per question
  quizActivityDays              Int      @default(3)    // 1-7 days of activity to use for quiz
  createdAt                     DateTime @default(now())
  updatedAt                     DateTime @updatedAt

  @@map("user_settings")
}

model ChatSession {
  id             String        @id @default(cuid())
  title          String?
  attentionRange String        @default("2h") // "30m" | "2h" | "1d" | "all"
  userId         String
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages       ChatMessage[]
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  @@index([userId])
  @@map("chat_sessions")
}

model ChatMessage {
  id            String      @id @default(cuid())
  sessionId     String
  session       ChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  role          String      // "user" | "assistant" | "tool"
  content       String      @db.Text
  status        String      @default("sent") // "sending" | "sent" | "typing" | "streaming" | "finished" | "error"
  errorMessage  String?
  // Tool-related fields (for role="tool" messages)
  toolCallId    String?     // ID linking tool call to tool result
  toolName      String?     // Name of the tool that was called
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@index([sessionId])
  @@map("chat_messages")
}

model Focus {
  id               String    @id @default(cuid())
  userId           String
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  item             String    // 2-3 word focus description
  keywords         String[]  // Historical keywords (max 10, then summarize)

  isActive         Boolean   @default(true)
  startedAt        DateTime  @default(now())
  endedAt          DateTime? // Set when drift detected or inactivity
  lastCalculatedAt DateTime  @default(now()) // For incremental processing
  lastActivityAt   DateTime  @default(now()) // For inactivity detection

  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@index([userId])
  @@index([userId, isActive])
  @@index([lastCalculatedAt])
  @@map("focuses")
}

model QuizResult {
  id             String   @id @default(cuid())
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  totalQuestions Int
  correctAnswers Int

  completedAt    DateTime @default(now())

  @@index([userId])
  @@index([userId, completedAt])
  @@map("quiz_results")
}

// Task Queue - Persistent per-user task queue for background processing
model TaskQueue {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Task definition
  type      String   // "focus_calculation" | "quiz_generation" | "summarization" | etc.
  priority  Int      @default(0) // Higher = more urgent (0 = normal, 10 = high, -10 = low)
  payload   Json     @default("{}") // Task-specific input data

  // Scheduling
  status    String   @default("pending") // "pending" | "processing" | "completed" | "failed" | "cancelled"
  scheduledFor DateTime @default(now()) // When the task should run (for delayed tasks)

  // Execution tracking
  startedAt   DateTime? // When processing began
  completedAt DateTime? // When processing finished
  attempts    Int      @default(0) // Retry counter
  maxAttempts Int      @default(3) // Max retries before failing

  // Results/errors
  result    Json?    // Task output (for completed tasks)
  error     String?  @db.Text // Error message (for failed tasks)

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([userId, status])
  @@index([status, scheduledFor]) // For worker to find ready tasks
  @@index([userId, type, status]) // For finding pending tasks of specific type
  @@map("task_queue")
}

// Task History - Completed/failed tasks moved here for visibility (read-only archive)
model TaskHistory {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Task definition (copied from TaskQueue)
  type      String
  priority  Int
  payload   Json     @default("{}")

  // Execution info (copied from TaskQueue)
  status    String   // "completed" | "failed" | "cancelled"
  attempts  Int

  // Timing (copied from TaskQueue)
  scheduledFor DateTime
  startedAt    DateTime?
  completedAt  DateTime

  // Results (copied from TaskQueue)
  result    Json?
  error     String?  @db.Text

  // Duration calculation (derived)
  durationMs Int? // completedAt - startedAt in milliseconds

  // Original task reference
  originalTaskId String // ID from TaskQueue before archival

  // Archive metadata
  archivedAt DateTime @default(now())

  @@index([userId])
  @@index([userId, type])
  @@index([userId, completedAt])
  @@index([userId, status])
  @@map("task_history")
}

